window.docContents[109].resolve({"/Introduction/#Documentation-MRiscX--Introduction--How-does--MRiscX--look-like":{"contents":"The concept of a Hoare-triple in MRiscX looks like this:\n\nexample (P Q : Prop) (l : UInt64)\n        (L_W L_B : Set UInt64)\n        (mriscx_code : Code) :\n  mriscx_code\n  ⦃P⦄ l ↦ ⟨L_W | L_B⟩ ⦃Q⦄\n  := by sorry\n\n\nBut what is happening here?\n\nThe example: and := by sorry is syntax provided by Lean itself.\nWith example: we can declare a theorem without the requirement to\nprovide a name. := by is the\nbeginning of the proof section. All the other lines of the code above\nare MRiscX-code. This is made possible by expanding the parser and elaborator\nof Lean.\n\nThere are two main sections in a Hoare-triple, which in turn can be\ndivided into multiple subsections:\n\n1. The Code section. For now, we just declared a variable of type Code,\nbut this can be replaced by actual RISC-V assembly code. More about this in the chapter\nabout the MRiscX assembly language.2. The Hoare-triple: This section consists of three subsections1. The precondition P2. The lines which are visited during runtime of this program.\n      This has the structure of l ↦ ⟨L_W | L_B⟩, where* l represent the line where the program starts\n            (where the ProgramCounter (PC) points to\n            before running the program).* L_W is the white list, a set containing all the lines where\n            the PC might point to after\n            executing the program. So when we want to let the program run for\n            one line.* L_B is a white list. This set contains all the lines, which must\n            not be visited during the runtime.3. The postcondition Q.More details about the Hoare-logic and Hoare-triples\n  are going to be explained later in the fundamentals chapter.\n\n","context":"Documentation MRiscX\u0009Introduction","header":"1.2. How does  MRiscX  look like","id":"/Introduction/#Documentation-MRiscX--Introduction--How-does--MRiscX--look-like"}});