window.docContents[47].resolve({"/Write-A-Specification/#preAndPostcondition":{"contents":"First of all, we need to be aware what our program is actually doing.\nOnce this is clear, we want to express this in first-order predicate logic.\n\nLet's take a look at some examples:\n\n#check\n  mriscx\n    first:\n            li x 1, 1\n            li x 2, 43\n            add x 3, x 1, x 2\n\n    finish:\n  end\n\n\nWe expect that after executing this program, registers x_1 and x_2 will contain the values\nthat were loaded into them, and register x_3 will contain the result of adding x_1 and x_2.\nThat means, the specification of this code snippet looks like this:\nx_1 = 1 \\wedge x_2 = 43 \\wedge x_3 = x_1 + x_2\n\nThe next example involves a loop:\n\nvariable (regWithAddr addr counter regWithValue\n          length: UInt64)\n#check\n  mriscx\n    first:\n            la x regWithAddr, addr\n            li x counter, length\n\n    loop:\n            beqz x counter, finish\n            sw x regWithValue, x addr\n            addi x addr, x addr, 1\n            subi x counter, x counter, 1\n            j loop\n\n    finish:\n  end\n\n\n\nIn this code, we have no concrete values, but some variables. This makes\nthe specification more general and we do not restrict the specification on\ncertain values.\nSo let's see what is happening here:\n\nFirst, an address addr is loaded into a register regWithAddr.\nThen, the loop is entered. It starts with a conditional jump, which happens when\nthe content of a register counter equals zero. If that is the case, we jump to the label\nfinish.\nWhen the register holds a value greater than zero, the actual loop body is entered.\nThe content of a register regWithValue is stored into the memory at the address the\nregister regWithAddr holds.\nOnce this is done, the address inside the register regWithAddr is incremented by one,\nthe value the register counter holds is decremented by one and we jump back to the\nlabel loop.\n\nLet \\text{memory}(n) denote the memory address n \\in \\mathbb{U}_{64}.\nThen, the specification of this program could be formulated as follows:\n\n\n\\begin{aligned}\n\\text{Pre} \\; \\coloneqq \\;\n& i < \\text{length}\n  \\;\\wedge\\;\n  \\text{addr} + \\text{length} - 1 < 2^{64} \\\\[0.5em]\n\\forall i \\in \\mathbb{U}_{64},\\;\n& \\text{Pre}\n  \\;\\rightarrow\\;\n  \\text{memory}(\\text{addr} + i)\n  = x_{\\text{regWithValue}}\n\\end{aligned}\n\n\nSo as you can see, we need multiple things to successfully write down a\ncorrect specification:\n\n1. First order logic with arithmetic expressions2. Access to the values (registers, memory, ...) of a certain machine state\n\nLuckily, 1. is already provided by Lean itself, so we just need to somehow\naccess a machine state.\nMRiscX offers a simple way to do this.\n\nInside the ⦃⦄ braces, we can write down first order logic formulas just like\nin usual terms of type Prop. Additionally, there are the following custom terms,\nwhich can be used:\n\n* ⸨terminated⸩This term is the MState.terminated flag.\n  It indicates whether the program has terminated and whether the current machine state is legal.\n  If this flag is true, the machine state is no longer legal, and no further instructions\n  can be executed.\n  Consequently, ⦃¬⸨terminated⸩⦄ serves as a precondition that is almost always\n  required to ensure that instructions can be executed and, ultimately, to establish the\n  functional correctness of a program.* ⸨pc⸩With this term, we can define the value of the MState.pc. Using this, we can\n  ensure that the MState.pc holds a certain value before or after\n  executing a program. Note, that l also ensures, that the MState.pc points to\n  a certain line before executing the program, so this term is often only useful in the\n  postcondition.* x[n], where n is either a number of type UInt64 or an identifier\n  (Lean.Parser.ident)Using this term we are able to define a value n for a register x_n in\n  MState.registers.\n  As already mentioned, this n can either be a number of type UInt64 or\n  an identifier.\n  This means, that the termsvariable (n v : UInt64)\n#check ⦃x[n] = v⦄\n#check ⦃x[1] = 42⦄\n#check ⦃x[1] = 0x4411⦄\nare all legal.\n  Also note, that Lean inherently supports hexadecimal numbers, so ⦃x[1] = 0x4411⦄\n  is legal and can (and should) be used to describe that a certain register holds a memory address.* mem[t], where t is a Lean.Term. This includes every custom term presented here.This term can be used to define a value of a certain place in the MState.memory.\n  Since it is possible to use the regular terms of Lean as well as the newly introduced\n  custom terms, we can load an address into a register, manipulate it and then use this register\n  inside the square brackets.#check ⦃mem[0x7ffe5367e044] = 4123⦄\n#check ⦃mem[x[2] + 1] = x[4] + x[5]⦄\n* labels[i], where i is of type Lean.Ident.Using this, we can ensure either that the label i exists on a specific line or that it does not\n  exist at all. Note, that the labels inside the code sections are already stored inside the\n  Code.labels, so they do not nee to be specified within the pre- or postcondition.This term returns an Option UInt64.#check ⦃labels[first] = some 0⦄\n#check ⦃labels[_L_store] = none⦄\n\n\nTo wrap things up, here is an example of a Hoare-triple with some of the terms presented:\n\n#check\n    mriscx\n      _start:\n              la x 2, 0x7ffe5367e044\n              addi x 2, x 2, 1\n              xori x 3, x 4, 412\n              sw x 3, x 2\n    end\n    ⦃¬⸨terminated⸩⦄\n    \"_start\" ↦ ⟨{\"_start\" + 4} | {n | n > \"_start\" + 4}\n                                      ∪ {\"_start\"}⟩\n    ⦃x[3] = x[4] ^^^ 412 ∧ mem[x[2] + 1] = x[3]⦄\n\n\n","context":"Documentation MRiscX\u0009Write A Specification","header":"3.1. Pre- And Postcondition","id":"/Write-A-Specification/#preAndPostcondition"}});