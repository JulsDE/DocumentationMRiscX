window.docContents[25].resolve({"/Fundamentals/#availableInstructions":{"contents":"In the current version of MRiscX, not all RISC-V instructions are available.\nHere is a list of the instructions which are implemented yet:\n\nDefinition of the Instructions.Load an address into a registerSyntax:la x dst, mwhere (dst m : UInt64).Note: Numbers of type UInt64 can be written as hexadecimal\n(e.g. 0xf123), which might serve as address.Load an immediate value into a registerSyntax:li x dst, mwhere (dst m : UInt64).Copy the contents of an a register into another registerSyntax:mv x dst, x regwhere (dst reg : UInt64).Add an immediate value and a register, store the result into a registerSyntax:addi x dst, x reg, mwhere (dst reg m : UInt64).Increment the content of a register by oneSyntax:inc x dstwhere (dst : UInt64).Add the contents of two registers and store the value into a registerSyntax:add x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Subtract an immediate value form a register, store the result into a\nthird registerSyntax:subi x dst, x reg, nwhere (dst reg n : UInt64).Decrement the content of a register by oneSyntax:dec x dstwhere (dst : UInt64).Subtract the value of a register form another register,\nstore the result into a third registerSyntax:sub x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Bitwise-XOR operation between an immediate value and the content of a\nregister, store the result into a registerSyntax:xor x dst, x reg, nwhere (dst reg n : UInt64).Bitwise-XOR operation between the contents of two registers,\nstore the result into a third registerSyntax:xor x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Load the content of the memory at the address which provided as an\nimmedtiate value into a registerSyntax:lw x dst, mem_addrwhere (dst mem_addr : UInt64).Load the content of the memory at the address which is stored in a register\ninto a registerSyntax:lw x dst, x reg_with_mem_addrwhere (dst reg_with_mem_addr : UInt64).Load the content of a register into the memory at the address which is\nstored in a registerSyntax:sw x reg_with_value, x reg_with_mem_addrwhere (reg_with_value reg_with_mem_addr : UInt64).Jump to a given labelname.Syntax:j labelwhere (label : ident).Note: Due to the elaboration, the actual syntax does not require a String\nbut an identifier (ident). Therefore, there is no need to use quotation\nmarks to represent a sequence of characters as a string type.\nThis is also true for all the following conditional jump instuctionsJump to a given labelname when the contents of two provided registers are\nequalSyntax:beq x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the contents of two provided registers are\nnot equalSyntax:bne x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis greater than the content of the other register provided.Syntax:bgt x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis less or equal the content of the other register provided.Syntax:ble x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the register provided\nis equal to zero.Syntax:beqz x reg, labelwhere (reg : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis greater than the content of the other register provided.Syntax:bnez x reg, labelwhere (reg : UInt64) (label : ident).Default instruction, sets the terminated flag to true\n\n","context":"Documentation MRiscX\u0009Fundamentals\u0009The Assembly Language","header":"2.1.1. Available Instructions","id":"/Fundamentals/#availableInstructions"}});