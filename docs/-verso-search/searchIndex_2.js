window.docContents[2].resolve({"/Fundamentals/#l_as":{"contents":"The “original” Hoare-logic cannot be applied without restriction to all programs\nand architectures. In structured programming, there are no restrictions on the\napplication of Hoare-logic, as the sequence of commands is precisely defined.\nIt is always clearly defined which command\nwill be executed next, and there is no possibility of jumping to any arbitrary\ncommand. A sequential chain is formed in which each link must be executed one\nafter the other. This is not the case in unstructured programming\n\nUnstructured Programming := Programming, that uses goto.\nJump commands such as goto can be used to jump to any point in\nthe code.\nDue to these restrictions on control flow and the limited ability\nto reason about intermediate program points - which is required to support complete\ncorrectness - the “classical” Hoare-triples are unsuitable for unstructured programs\n.\nSince MRiscX contains elements of unstructured programming,\nan extended form of Hoare-logic is used, as presented by .\n\nIn the following, the function MState.runOneStep executes a single instruction,\nthereby transforming a machine state s into a successor state s'.\nThe function MState.runNSteps denotes the n-th iteration of MState.runOneStep.\n\nFurthermore, MState.pc returns the line to which the ProgramCounter points in a\ngiven machine state s.\n\nWithin this framework, MState.runOneStep corresponds to the function nxt, and\nMState.pc corresponds to the function lbl from the\n weak transition relation introduced in\n.\n\nUsing these definitions, the weak transition relation in MRiscX is formalized as\nfollows:\n\nnamespace myNameSpace\ndef weak (s s' : MState) (L_w L_b : Set UInt64)\n    (c : Code) : Prop :=\n  s.code = c →\n  ∃ (n:Nat), n > 0 ∧ s.runNSteps n = s' ∧ (s'.pc) ∈ L_w ∧\n  ∀ (n':Nat), 0 < n' ∧ n' < n →\n  (s.runNSteps n').pc ∉ (L_w ∪ L_b)\n\n\nThis weak relation, inspired by Lundberg et al. (2020),\nis defined over two MStates, s and s'.\nUnlike earlier formulations that take a single set of lines L,\nthis relation is parameterized by two sets of lines, L_w and L_b.This design has the advantage that the condition s'.pc ∈ L_w is already guaranteed\nby the relation itself. Since we assume L_w ∩ L_b = ∅, it immediately follows that\ns'.pc ∉ L_b must also hold. Consequently, the explicit postcondition s'.pc ∈ L_b in\nthe Judgment of L_as could be omitted. However, this simplification has not yet been\napplied in the current version.This relation is defined as follows:State s' is reached from state s after exactly n steps, where n > 0, and the program\ncounter of s' points to a line in L_w. Moreover, there exists no n' ∈ ℕ with 0 < n' < n\nsuch that the state reached after n' steps from s has its program counter in L_w ∪ L_b.\nIn other words, s' is the first state along the execution path whose program counter lies\nin L_w.The weak relation is deterministic and partial: a program starting in s may never reach a\nstate whose program counter lies in L_w. Additionally, the relation guarantees that no\nintermediate state between s and s' has a program counter in L_w.With the help of this relation, unambiguous statements can be made about the flow of the program.\n\nThe weak transition relation has two machine states,\ns and s', and two sets of lines, L_W and L_B, as arguments.\nThis relation now states the following:\n\nIf n \\in \\mathbb{N} with n > 0 steps are taken from state s, state s' is reached.\nThe PC of s' points to a line that is an element of L_W.\nFurthermore, there is no n' \\in \\mathbb{N} with 0 < n' < n\nsuch that after n' steps from state s, state s' is reached, whose PC also points to a\nline which is an element of L_W \\cup L_B .\nL_W is referred to as the whitelist and L_B as the blacklist.\n\nThe weak transition relation is deterministic and partial,\nsince a program that starts in s may never reach L_W.\nIt also guarantees that no intermediate state  s'' exists between s and s' with\ns''.pc \\in L_W \\cup L_B.\n\nWith the help of this relation, unambiguous statements can be made about the flow of the program.\n\nIn order to formulate a Hoare-triple, the function hoare_triple_up can be used.\nThis function is inspired by the\n\\text{judgment of } \\mathcal{L}_\\text{AS} in \n\nThis hoare_triple_up function is defined as follows:\n\ndef hoare_triple_up (P Q : Assertion) (l : UInt64)\n    (L_w L_b : Set UInt64) (c : Code) :=\n  L_w ∩ L_b = ∅ →\n  L_w ≠ ∅ →\n  ∀ (s : MState), s.code = c →\n  s.pc = l →\n  P s →\n  ∃ (s' : MState),\n  (weak s s' L_w L_b c) ∧ Q s' ∧ s'.pc ∉ L_b\n\nend myNameSpace\n\n\nInspired by the judgement of L_{as} in the paper Lundberg et al. (2020).Suppose, that L_w ∩ L_b = ∅ and L_w ≠ ∅ hold, then the hoare_triple_up means:For all states s in which both P(s) and I(s) are satisfied and whose\nprogram counter points to l,\nthere exists a successor state s' for which both the relation\nweak(s, L_w ∪ L_b, s') and Q(s'), I(s') and s'.pc ∉ L_w\nare satisfied.\n\nThe notation introduced for a Hoare-triple looks like this:\n\nexample (P Q : Prop) (l : UInt64) (L_w L_b : Set UInt64)\n    (mriscx_code : Code):\n  mriscx_code\n  ⦃P⦄ l ↦ ⟨L_w | L_b⟩ ⦃Q⦄\n  := by sorry\n\n\n, where P and Q represent the pre- and postcondition, l the line the PC points to\nbefore executing the first instruction, L_W the whitelist and L_B the blacklist.\n\n","context":"Documentation MRiscX\u0009Fundamentals","header":"2.3. Extension Of The Hoare-Logic  <missing>","id":"/Fundamentals/#l_as"}});